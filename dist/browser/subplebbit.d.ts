/// <reference types="node" />
import EventEmitter from "events";
import { ChallengeAnswerMessage } from "./challenge";
import { Signer } from "./signer";
import { Pages } from "./pages";
import { Plebbit } from "./plebbit";
import { ChallengeType, DbHandlerPublicAPI, DecryptedChallengeAnswerMessageType, DecryptedChallengeRequestMessageType, Flair, FlairOwner, InternalSubplebbitType, ProtocolVersion, SubplebbitEditOptions, SubplebbitEncryption, SubplebbitFeatures, SubplebbitIpfsType, SubplebbitMetrics, SubplebbitRole, SubplebbitSuggested, SubplebbitType } from "./types";
import { SignatureType } from "./signer/constants";
export declare class Subplebbit extends EventEmitter implements Omit<SubplebbitType, "posts"> {
    title?: string;
    description?: string;
    roles?: {
        [authorAddress: string]: SubplebbitRole;
    };
    lastPostCid?: string;
    posts: Pages;
    pubsubTopic: string;
    challengeTypes?: ChallengeType[];
    metrics?: SubplebbitMetrics;
    features?: SubplebbitFeatures;
    suggested?: SubplebbitSuggested;
    flairs?: Record<FlairOwner, Flair[]>;
    address: string;
    metricsCid?: string;
    createdAt: number;
    updatedAt: number;
    signer?: Signer;
    encryption: SubplebbitEncryption;
    protocolVersion: ProtocolVersion;
    signature: SignatureType;
    rules?: string[];
    plebbit: Plebbit;
    dbHandler?: DbHandlerPublicAPI;
    private _challengeToSolution;
    private _challengeToPublicKey;
    private _challengeToPublication;
    private provideCaptchaCallback;
    private validateCaptchaAnswerCallback;
    private sortHandler;
    private _updateInterval?;
    private _updateIntervalMs;
    private _syncInterval?;
    private _syncIntervalMs;
    private _sync;
    private _ipfsNodeIpnsKeyNames;
    private _subplebbitUpdateTrigger;
    constructor(plebbit: Plebbit);
    initSubplebbit(newProps: InternalSubplebbitType | SubplebbitEditOptions | SubplebbitIpfsType): Promise<void>;
    private _initSignerProps;
    private initDbHandlerIfNeeded;
    setProvideCaptchaCallback(newCallback: (request: DecryptedChallengeRequestMessageType) => Promise<[ChallengeType[], string | undefined]>): void;
    setValidateCaptchaAnswerCallback(newCallback: (answerMessage: DecryptedChallengeAnswerMessageType) => Promise<[boolean, string[] | undefined]>): void;
    toJSONInternal(): InternalSubplebbitType;
    toJSON(): SubplebbitType;
    private _toJSONBase;
    toJSONIpfs(): SubplebbitIpfsType;
    private _importSignerIntoIpfsIfNeeded;
    prePublish(): Promise<void>;
    private assertDomainResolvesCorrectly;
    edit(newSubplebbitOptions: SubplebbitEditOptions): Promise<Subplebbit>;
    private updateOnce;
    update(): Promise<void>;
    stop(): Promise<void>;
    private _validateLocalSignature;
    private updateSubplebbitIpnsIfNeeded;
    private handleCommentEdit;
    private handleVote;
    private isPublicationVote;
    private isPublicationComment;
    private isPublicationReply;
    private isPublicationPost;
    private isPublicationCommentEdit;
    private storePublicationIfValid;
    private handleChallengeRequest;
    handleChallengeAnswer(challengeAnswer: ChallengeAnswerMessage): Promise<void>;
    private _verifyPubsubMsgSignature;
    private handleChallengeExchange;
    private defaultProvideCaptcha;
    private defaultValidateCaptcha;
    private _publishCommentIpns;
    private _validateCommentUpdate;
    private _updateComment;
    private _listenToIncomingRequests;
    private _getDbInternalState;
    private _mergeInstanceStateWithDbState;
    private _switchDbIfNeeded;
    private _updateCommentsThatNeedToBeUpdated;
    private syncIpnsWithDb;
    private _updateDbInternalState;
    private _syncLoop;
    start(): Promise<void>;
    delete(): Promise<void>;
}

/// <reference types="node" />
import EventEmitter from "events";
import { ChallengeAnswerMessage, ChallengeRequestMessage } from "./challenge";
import { Signer } from "./signer";
import { Pages } from "./pages";
import { Plebbit } from "./plebbit";
import { ChallengeType, CreateSubplebbitOptions, DbHandlerPublicAPI, DecryptedChallengeAnswerMessageType, DecryptedChallengeRequestMessageType, Flair, FlairOwner, ProtocolVersion, SignatureType, SubplebbitEditOptions, SubplebbitEncryption, SubplebbitFeatures, SubplebbitMetrics, SubplebbitRole, SubplebbitSuggested, SubplebbitType } from "./types";
import { Comment } from "./comment";
import Vote from "./vote";
import Post from "./post";
import { CommentEdit } from "./comment-edit";
export declare const RUNNING_SUBPLEBBITS: Record<string, boolean>;
export declare class Subplebbit extends EventEmitter implements SubplebbitType {
    title?: string;
    description?: string;
    roles?: {
        [authorAddress: string]: SubplebbitRole;
    };
    lastPostCid?: string;
    posts: Pages;
    pubsubTopic: string;
    challengeTypes?: ChallengeType[];
    metrics?: SubplebbitMetrics;
    features?: SubplebbitFeatures;
    suggested?: SubplebbitSuggested;
    flairs?: Record<FlairOwner, Flair[]>;
    address: string;
    metricsCid?: string;
    createdAt: number;
    updatedAt: number;
    signer?: Signer;
    encryption: SubplebbitEncryption;
    protocolVersion: ProtocolVersion;
    signature: SignatureType;
    rules?: string[];
    plebbit: Plebbit;
    dbHandler?: DbHandlerPublicAPI;
    database?: any;
    private _challengeToSolution;
    private _challengeToPublication;
    private provideCaptchaCallback;
    private validateCaptchaAnswerCallback;
    private ipnsKeyName?;
    private sortHandler;
    private _updateInterval?;
    private _syncInterval?;
    private _sync;
    constructor(props: CreateSubplebbitOptions, plebbit: Plebbit);
    initSubplebbit(newProps: SubplebbitType | SubplebbitEditOptions): void;
    initSignerIfNeeded(): Promise<void>;
    initDbIfNeeded(): Promise<void>;
    setProvideCaptchaCallback(newCallback: (request: DecryptedChallengeRequestMessageType) => Promise<[ChallengeType[], string | undefined]>): void;
    setValidateCaptchaAnswerCallback(newCallback: (answerMessage: DecryptedChallengeAnswerMessageType) => Promise<[boolean, string[] | undefined]>): void;
    toJSONInternal(): {
        ipnsKeyName: string;
        database: any;
        signer: Signer;
        signature: SignatureType;
        encryption: SubplebbitEncryption;
        address: string;
        createdAt: number;
        updatedAt: number;
        pubsubTopic: string;
        metricsCid?: string;
        protocolVersion: "1.0.0";
        posts: Pages | Pick<Pages, "pageCids" | "pages">;
        description?: string;
        title?: string;
        roles?: {
            [authorAddress: string]: SubplebbitRole;
        };
        lastPostCid?: string;
        challengeTypes?: ChallengeType[];
        features?: SubplebbitFeatures;
        suggested?: SubplebbitSuggested;
        rules?: string[];
        flairs?: Record<FlairOwner, Flair[]>;
        metrics?: SubplebbitMetrics;
    };
    toJSON(): SubplebbitType;
    prePublish(): Promise<void>;
    assertDomainResolvesCorrectly(domain: string): Promise<void>;
    edit(newSubplebbitOptions: SubplebbitEditOptions): Promise<Subplebbit>;
    updateOnce(): Promise<this>;
    update(updateIntervalMs?: number): Promise<this>;
    stop(): Promise<void>;
    updateSubplebbitIpns(): Promise<void>;
    handleCommentEdit(commentEdit: CommentEdit, challengeRequestId: string): Promise<string>;
    handleVote(newVote: Vote, challengeRequestId: string): Promise<string>;
    storePublicationIfValid(publication: DecryptedChallengeRequestMessageType["publication"], challengeRequestId: string): Promise<Vote | CommentEdit | Post | Comment | string>;
    handleChallengeRequest(request: ChallengeRequestMessage): Promise<void>;
    handleChallengeAnswer(challengeAnswer: ChallengeAnswerMessage): Promise<void>;
    private _verifyPubsubMsgSignature;
    handleChallengeExchange(pubsubMsg: any): Promise<void>;
    defaultProvideCaptcha(request: DecryptedChallengeRequestMessageType): Promise<[ChallengeType[], string | undefined]>;
    defaultValidateCaptcha(answerMessage: DecryptedChallengeAnswerMessageType): Promise<[boolean, string[] | undefined]>;
    syncComment(dbComment: Comment): Promise<void>;
    syncIpnsWithDb(): Promise<void>;
    _syncLoop(syncIntervalMs: number): Promise<void>;
    start(syncIntervalMs?: number): Promise<void>;
    _addPublicationToDb(publication: CommentEdit | Vote | Comment | Post): Promise<string | CommentEdit | Vote | Comment | Post>;
}

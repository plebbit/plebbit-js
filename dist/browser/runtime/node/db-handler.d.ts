import { Knex } from "knex";
import Transaction = Knex.Transaction;
import { AuthorCommentEdit, ChallengeAnswersTableRowInsert, ChallengeRequestsTableRowInsert, ChallengesTableRowInsert, ChallengeVerificationsTableRowInsert, CommentEditsTableRowInsert, CommentsTableRow, CommentsTableRowInsert, CommentUpdate, CommentUpdatesRow, CommentUpdatesTableRowInsert, CommentWithCommentUpdate, SignersTableRow, SingersTableRowInsert, SubplebbitAuthor, SubplebbitStats, VotesTableRow, VotesTableRowInsert } from "../../types";
import { PageOptions } from "../../sort-handler";
export declare class DbHandler {
    private _knex;
    private _subplebbit;
    private _currentTrxs;
    private _dbConfig;
    private _keyv;
    private _createdTables;
    constructor(subplebbit: DbHandler["_subplebbit"]);
    initDbConfigIfNeeded(): Promise<void>;
    initDbIfNeeded(): Promise<void>;
    getDbConfig(): Knex.Config;
    keyvGet(key: string, options?: {
        raw?: false;
    }): Promise<any>;
    keyvSet(key: string, value: any, ttl?: number): Promise<true>;
    keyvDelete(key: string | string[]): Promise<boolean>;
    keyvHas(key: string): Promise<boolean>;
    initDestroyedConnection(): Promise<void>;
    destoryConnection(): Promise<void>;
    createTransaction(transactionId: string): Promise<Transaction>;
    commitTransaction(transactionId: string): Promise<void>;
    rollbackTransaction(transactionId: string): Promise<void>;
    rollbackAllTransactions(): Promise<void[]>;
    private _baseTransaction;
    private _createCommentsTable;
    private _createCommentUpdatesTable;
    private _createVotesTable;
    private _createChallengeRequestsTable;
    private _createChallengesTable;
    private _createChallengeAnswersTable;
    private _createChallengeVerificationsTable;
    private _createSignersTable;
    private _createCommentEditsTable;
    getDbVersion(): Promise<number>;
    createTablesIfNeeded(): Promise<void>;
    isDbInMemory(): boolean;
    private _copyTable;
    deleteVote(authorAddress: VotesTableRow["authorAddress"], commentCid: VotesTableRow["commentCid"], trx?: Transaction): Promise<void>;
    insertVote(vote: VotesTableRowInsert, trx?: Transaction): Promise<void>;
    insertComment(comment: CommentsTableRowInsert, trx?: Transaction): Promise<void>;
    upsertCommentUpdate(update: CommentUpdatesTableRowInsert, trx?: Transaction): Promise<void>;
    insertEdit(edit: CommentEditsTableRowInsert, trx?: Transaction): Promise<void>;
    insertChallengeRequest(request: ChallengeRequestsTableRowInsert, trx?: Transaction): Promise<void>;
    insertChallenge(challenge: ChallengesTableRowInsert, trx?: Transaction): Promise<void>;
    insertChallengeAnswer(answer: ChallengeAnswersTableRowInsert, trx?: Transaction): Promise<void>;
    insertChallengeVerification(verification: ChallengeVerificationsTableRowInsert, trx?: Transaction): Promise<void>;
    getLastVoteOfAuthor(commentCid: string, authorAddress: string, trx?: Transaction): Promise<VotesTableRow | undefined>;
    private _basePageQuery;
    queryReplyCount(commentCid: string, trx?: Transaction): Promise<number>;
    queryCommentsForPages(options: Omit<PageOptions, "pageSize">, trx?: Transaction): Promise<{
        comment: CommentsTableRow;
        update: CommentUpdatesRow;
    }[]>;
    queryStoredCommentUpdate(comment: Pick<CommentsTableRow, "cid">, trx?: any): Promise<CommentUpdatesRow | undefined>;
    queryCommentsOfAuthor(authorAddresses: string | string[], trx?: Transaction): Promise<CommentsTableRow[]>;
    queryAllCommentsCid(trx?: Transaction): Promise<string[]>;
    queryCommentsByCids(cids: string[], trx?: Transaction): Promise<CommentsTableRow[]>;
    queryParents(rootComment: Pick<CommentsTableRow, "cid" | "parentCid">, trx?: Transaction): Promise<CommentsTableRow[]>;
    queryCommentsToBeUpdated(ipnsKeyNames: string[], trx?: Transaction): Promise<CommentsTableRow[]>;
    querySubplebbitStats(trx?: Transaction): Promise<SubplebbitStats>;
    queryCommentsUnderComment(parentCid: string | null, trx?: Transaction): Promise<CommentsTableRow[]>;
    queryComment(cid: string, trx?: Transaction): Promise<CommentsTableRow | undefined>;
    private _queryCommentUpvote;
    private _queryCommentDownvote;
    private _queryCommentCounts;
    private _queryAuthorEdit;
    private _queryLatestModeratorReason;
    queryCommentFlags(cid: string, trx?: Transaction): Promise<Pick<CommentUpdate, "spoiler" | "pinned" | "locked" | "removed">>;
    queryAuthorEditDeleted(cid: string, trx?: Transaction): Promise<AuthorCommentEdit["deleted"] | undefined>;
    private _queryModCommentFlair;
    queryCalculatedCommentUpdate(comment: Pick<CommentsTableRow, "cid" | "author">, trx?: Transaction): Promise<Omit<CommentUpdate, "signature" | "updatedAt" | "replies" | "protocolVersion">>;
    queryLatestPostCid(trx?: Transaction): Promise<Pick<CommentWithCommentUpdate, "cid"> | undefined>;
    insertSigner(signer: SingersTableRowInsert, trx?: Transaction): Promise<number[]>;
    querySigner(ipnsKeyName: string, trx?: Transaction): Promise<SignersTableRow | undefined>;
    queryAuthorModEdits(authorAddress: string, trx?: Knex.Transaction): Promise<Pick<SubplebbitAuthor, "banExpiresAt" | "flair">>;
    querySubplebbitAuthor(authorAddress: string, trx?: Knex.Transaction): Promise<SubplebbitAuthor>;
    changeDbFilename(newDbFileName: string, newSubplebbit: DbHandler["_subplebbit"]): Promise<void>;
    lockSubStart(subAddress?: string): Promise<void>;
    unlockSubStart(subAddress?: string): Promise<void>;
    isSubStartLocked(subAddress?: string): Promise<boolean>;
    lockSubCreation(subAddress?: string): Promise<void>;
    unlockSubCreation(subAddress?: string): Promise<void>;
    isSubCreationLocked(subAddress?: string): Promise<boolean>;
    lockSubState(subAddress?: string): Promise<void>;
    unlockSubState(subAddress?: string): Promise<void>;
    subDbExists(subAddress?: string): boolean;
    subAddress(): string;
}

import Publication from "../publication.js";
import { RepliesPages } from "../../pages.js";
import { AuthorCommentEdit, CommentIpfsType, CommentIpfsWithCid, CommentPubsubMessage, CommentsTableRowInsert, CommentTypeJson, CommentUpdate, CommentWithCommentUpdateJson, DecryptedChallengeRequestComment, DecryptedChallengeVerificationMessageTypeWithSubplebbitAuthor, LocalCommentOptions, PageTypeJson, PublicationTypeName, RepliesPagesTypeIpfs } from "../../types.js";
import { Plebbit } from "../../plebbit.js";
import { CommentClientsManager } from "../../clients/client-manager.js";
import { Flair } from "../../subplebbit/types.js";
export declare class Comment extends Publication {
    shortCid?: string;
    clients: CommentClientsManager["clients"];
    title?: string;
    link?: string;
    linkWidth?: number;
    linkHeight?: number;
    thumbnailUrl?: string;
    thumbnailUrlWidth?: number;
    thumbnailUrlHeight?: number;
    cid?: string;
    parentCid?: string;
    content?: string;
    previousCid?: string;
    depth?: number;
    postCid?: string;
    linkHtmlTagName?: "a" | "img" | "video" | "audio";
    original?: CommentWithCommentUpdateJson["original"];
    upvoteCount?: number;
    downvoteCount?: number;
    replyCount?: number;
    updatedAt?: number;
    replies: RepliesPages;
    edit?: AuthorCommentEdit;
    flair?: Flair;
    deleted?: boolean;
    spoiler?: boolean;
    pinned?: boolean;
    locked?: boolean;
    removed?: boolean;
    reason?: string;
    lastChildCid?: string;
    lastReplyTimestamp?: number;
    updatingState: "stopped" | "resolving-author-address" | "fetching-ipfs" | "fetching-update-ipfs" | "resolving-subplebbit-address" | "fetching-subplebbit-ipns" | "fetching-subplebbit-ipfs" | "failed" | "succeeded";
    private _updateInterval?;
    private _isUpdating;
    private _rawCommentUpdate?;
    private _rawCommentIpfs?;
    private _loadingOperation?;
    _clientsManager: CommentClientsManager;
    private _updateRpcSubscriptionId?;
    constructor(plebbit: Plebbit);
    _initClients(): void;
    private _setOriginalFieldBeforeModifying;
    _initLocalProps(props: LocalCommentOptions): void;
    _initPubsubMessageProps(props: CommentPubsubMessage): void;
    _initIpfsProps(props: CommentIpfsType): void;
    _initChallengeRequestProps(props: DecryptedChallengeRequestComment): void;
    _initCommentUpdate(props: CommentUpdate | CommentWithCommentUpdateJson): Promise<void>;
    _updateRepliesPostsInstance(newReplies: CommentUpdate["replies"] | CommentWithCommentUpdateJson["replies"] | Pick<RepliesPagesTypeIpfs, "pageCids">): Promise<void>;
    _updateLocalCommentPropsWithVerification(props: NonNullable<DecryptedChallengeVerificationMessageTypeWithSubplebbitAuthor["publication"]>): void;
    getType(): PublicationTypeName;
    toJSON(): CommentTypeJson;
    toJSONCommentIpfsWithCid(): CommentIpfsWithCid;
    toJSONPagesIpfs(commentUpdate: CommentUpdate): {
        comment: CommentIpfsWithCid;
        update: CommentUpdate;
    };
    toJSONIpfs(): CommentIpfsType;
    toJSONPubsubMessagePublication(): CommentPubsubMessage;
    toJSONAfterChallengeVerification(): NonNullable<DecryptedChallengeVerificationMessageTypeWithSubplebbitAuthor["publication"]>;
    toJSONCommentsTableRowInsert(publicationHash: CommentsTableRowInsert["challengeRequestPublicationSha256"], authorSignerAddress: string): CommentsTableRowInsert;
    toJSONCommentWithinPage(): PageTypeJson["comments"][0];
    setPostCid(newPostCid: string): void;
    setCid(newCid: string): void;
    setSubplebbitAddress(newSubplebbitAddress: string): void;
    setPreviousCid(newPreviousCid?: string): void;
    setDepth(newDepth: number): void;
    setUpdatedAt(newUpdatedAt: number): void;
    private _retryLoadingCommentIpfs;
    private _retryLoadingCommentUpdate;
    updateOnce(): Promise<void>;
    _setUpdatingState(newState: Comment["updatingState"]): void;
    protected _setRpcClientState(newState: Comment["clients"]["plebbitRpcClients"][""]["state"]): void;
    protected _updateRpcClientStateFromUpdatingState(updatingState: Comment["updatingState"]): void;
    private _isCriticalRpcError;
    update(): Promise<void>;
    private _stopUpdateLoop;
    stop(): Promise<void>;
    private _validateSignature;
    publish(): Promise<void>;
}

import Publication from "../publication.js";
import type { DecryptedChallengeVerification } from "../../pubsub-messages/types.js";
import type { AuthorWithOptionalCommentUpdateJson, PublicationTypeName } from "../../types.js";
import type { RepliesPagesTypeIpfs } from "../../pages/types.js";
import Logger from "@plebbit/plebbit-logger";
import { Plebbit } from "../../plebbit/plebbit.js";
import type { CommentIpfsType, CommentIpfsWithCidPostCidDefined, CommentPubsubMessagePublication, CommentRawField, CommentState, CommentUpdateForChallengeVerification, CommentUpdateType, CommentWithinRepliesPostsPageJson, CreateCommentOptions } from "./types.js";
import { RepliesPages } from "../../pages/pages.js";
import type { SignerType } from "../../signer/types.js";
import { CommentClientsManager } from "./comment-client-manager.js";
import type { SubplebbitIpfsType } from "../../subplebbit/types.js";
import type { PublicationEventArgs, PublicationEvents } from "../types.js";
export declare class Comment extends Publication implements Partial<CommentUpdateForChallengeVerification>, CommentPubsubMessagePublication, Partial<CommentIpfsWithCidPostCidDefined>, Partial<Omit<CommentUpdateType, "replies">> {
    shortCid?: CommentWithinRepliesPostsPageJson["shortCid"];
    clients: CommentClientsManager["clients"];
    author: AuthorWithOptionalCommentUpdateJson;
    title?: CommentPubsubMessagePublication["title"];
    link?: CommentPubsubMessagePublication["link"];
    linkWidth?: CommentPubsubMessagePublication["linkWidth"];
    linkHeight?: CommentPubsubMessagePublication["linkHeight"];
    thumbnailUrl?: CommentIpfsType["thumbnailUrl"];
    thumbnailUrlWidth?: CommentIpfsType["thumbnailUrlWidth"];
    thumbnailUrlHeight?: CommentIpfsType["thumbnailUrlHeight"];
    cid?: CommentIpfsWithCidPostCidDefined["cid"];
    parentCid?: CommentIpfsType["parentCid"];
    quotedCids?: CommentPubsubMessagePublication["quotedCids"];
    content?: CommentPubsubMessagePublication["content"];
    previousCid?: CommentIpfsType["previousCid"];
    depth?: CommentIpfsType["depth"];
    postCid?: CommentIpfsType["postCid"];
    pseudonymityMode?: CommentIpfsType["pseudonymityMode"];
    linkHtmlTagName?: CommentPubsubMessagePublication["linkHtmlTagName"];
    original?: CommentWithinRepliesPostsPageJson["original"];
    upvoteCount?: CommentUpdateType["upvoteCount"];
    downvoteCount?: CommentUpdateType["downvoteCount"];
    replyCount?: CommentUpdateType["replyCount"];
    childCount?: CommentUpdateType["childCount"];
    updatedAt?: CommentUpdateType["updatedAt"];
    replies: RepliesPages;
    edit?: CommentUpdateType["edit"];
    flairs?: CommentPubsubMessagePublication["flairs"];
    deleted?: CommentWithinRepliesPostsPageJson["deleted"];
    spoiler?: CommentIpfsType["spoiler"];
    nsfw?: CommentIpfsType["nsfw"];
    pinned?: CommentUpdateType["pinned"];
    locked?: CommentUpdateType["locked"];
    archived?: CommentUpdateType["archived"];
    removed?: CommentUpdateType["removed"];
    reason?: CommentUpdateType["reason"];
    lastChildCid?: CommentUpdateType["lastChildCid"];
    lastReplyTimestamp?: CommentUpdateType["lastReplyTimestamp"];
    pendingApproval?: CommentUpdateForChallengeVerification["pendingApproval"];
    approved?: CommentUpdateType["approved"];
    number?: CommentUpdateType["number"];
    postNumber?: CommentUpdateType["postNumber"];
    signature: CommentPubsubMessagePublication["signature"];
    state: CommentState;
    private _updatingState;
    raw: CommentRawField;
    _commentUpdateIpfsPath?: string;
    _invalidCommentUpdateMfsPaths: Set<string>;
    private _commentIpfsloadingOperation?;
    _clientsManager: CommentClientsManager;
    private _updateRpcSubscriptionId?;
    challengeRequest?: CreateCommentOptions["challengeRequest"];
    private _subplebbitForUpdating?;
    private _postForUpdating?;
    _numOfListenersForUpdatingInstance: number;
    _updatingCommentInstance?: {
        comment: Comment;
    } & Pick<PublicationEvents, "error" | "updatingstatechange" | "update" | "statechange">;
    constructor(plebbit: Plebbit);
    _initClients(): void;
    private _setOriginalFieldBeforeModifying;
    _initLocalProps(props: {
        comment: CommentPubsubMessagePublication;
        signer?: SignerType;
        challengeRequest?: CreateCommentOptions["challengeRequest"];
    }): void;
    _initPubsubMessageProps(props: CommentPubsubMessagePublication): void;
    _initIpfsProps(props: CommentIpfsType): void;
    _initProps(props: CommentIpfsType | CommentPubsubMessagePublication): void;
    _initCommentUpdate(props: CommentUpdateType | CommentWithinRepliesPostsPageJson, subplebbit?: Pick<SubplebbitIpfsType, "signature">): void;
    _updateRepliesPostsInstance(newReplies: CommentUpdateType["replies"] | CommentWithinRepliesPostsPageJson["replies"] | Pick<RepliesPagesTypeIpfs, "pageCids">, subplebbit?: Pick<SubplebbitIpfsType, "signature">): void;
    private _verifyChallengeVerificationCommentProps;
    private _addOwnCommentToIpfsIfConnectedToIpfsClient;
    _initCommentUpdateFromChallengeVerificationProps(commentUpdate: CommentUpdateForChallengeVerification): void;
    private _updateCommentPropsFromDecryptedChallengeVerification;
    protected _verifyDecryptedChallengeVerificationAndUpdateCommentProps(decryptedVerification: DecryptedChallengeVerification): Promise<void>;
    getType(): PublicationTypeName;
    toJSONIpfs(): CommentIpfsType;
    toJSONPubsubMessagePublication(): CommentPubsubMessagePublication;
    setCid(newCid: string): void;
    setSubplebbitAddress(newSubplebbitAddress: string): void;
    private _isCommentIpfsErrorRetriable;
    private _retryLoadingCommentIpfs;
    _attemptToFetchCommentIpfsIfNeeded(log: Logger): Promise<void>;
    _attemptInfintelyToLoadCommentIpfs(): Promise<void>;
    startCommentUpdateSubplebbitSubscription(): Promise<void>;
    loadCommentIpfsAndStartCommentUpdateSubscription(): Promise<void>;
    _setUpdatingStateNoEmission(newState: Comment["updatingState"]): void;
    get updatingState(): Comment["_updatingState"];
    _changeCommentStateEmitEventEmitStateChangeEvent<T extends keyof Omit<PublicationEvents, "statechange" | "updatingstatechange">>(opts: {
        event: {
            name: T;
            args: PublicationEventArgs<T>;
        };
        newUpdatingState?: Comment["updatingState"];
        newState?: Comment["state"];
    }): void;
    _setUpdatingStateWithEmissionIfNewState(newState: Comment["updatingState"]): void;
    protected _setRpcClientState(newState: Comment["clients"]["plebbitRpcClients"][""]["state"]): void;
    protected _updateRpcClientStateFromUpdatingState(updatingState: Comment["updatingState"]): void;
    private _isRetriableLoadingError;
    private _handleCommentEventFromRpc;
    private _handleUpdateEventFromRpc;
    private _handleUpdatingStateChangeFromRpc;
    private _handleStateChangeFromRpc;
    private _handleErrorEventFromRpc;
    private _updateViaRpc;
    _useUpdatePropsFromUpdatingStartedSubplebbitIfPossible(): void;
    _useUpdatePropsFromUpdatingCommentIfPossible(): void;
    _useUpdatingCommentFromPlebbit(updatingCommentInstance: Comment): void;
    _setUpNewUpdatingCommentInstance(): Promise<void>;
    update(): Promise<void>;
    private _stopUpdateLoop;
    stop(): Promise<void>;
    private _validateSignature;
    publish(): Promise<void>;
}

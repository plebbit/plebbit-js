import Publication from "../publication.js";
import type { DecryptedChallengeVerification } from "../../pubsub-messages/types.js";
import type { AuthorWithOptionalCommentUpdateJson, PublicationEvents, PublicationTypeName } from "../../types.js";
import type { RepliesPagesTypeIpfs } from "../../pages/types.js";
import Logger from "@plebbit/plebbit-logger";
import { Plebbit } from "../../plebbit/plebbit.js";
import type { CommentIpfsType, CommentIpfsWithCidPostCidDefined, CommentPubsubMessagePublication, CommentState, CommentUpdateForChallengeVerification, CommentUpdateType, CommentUpdatingState, CommentWithinPageJson, CreateCommentOptions } from "./types.js";
import { RepliesPages } from "../../pages/pages.js";
import type { SignerType } from "../../signer/types.js";
import { CommentClientsManager } from "./comment-client-manager.js";
import type { SubplebbitIpfsType } from "../../subplebbit/types.js";
export declare class Comment extends Publication implements CommentPubsubMessagePublication, Partial<CommentIpfsWithCidPostCidDefined>, Partial<Omit<CommentUpdateType, "replies">> {
    shortCid?: CommentWithinPageJson["shortCid"];
    clients: CommentClientsManager["clients"];
    author: AuthorWithOptionalCommentUpdateJson;
    title?: CommentPubsubMessagePublication["title"];
    link?: CommentPubsubMessagePublication["link"];
    linkWidth?: CommentPubsubMessagePublication["linkWidth"];
    linkHeight?: CommentPubsubMessagePublication["linkHeight"];
    thumbnailUrl?: CommentIpfsType["thumbnailUrl"];
    thumbnailUrlWidth?: CommentIpfsType["thumbnailUrlWidth"];
    thumbnailUrlHeight?: CommentIpfsType["thumbnailUrlHeight"];
    cid?: CommentIpfsWithCidPostCidDefined["cid"];
    parentCid?: CommentIpfsType["parentCid"];
    content?: CommentPubsubMessagePublication["content"];
    previousCid?: CommentIpfsType["previousCid"];
    depth?: CommentIpfsType["depth"];
    postCid?: CommentIpfsType["postCid"];
    linkHtmlTagName?: CommentPubsubMessagePublication["linkHtmlTagName"];
    original?: CommentWithinPageJson["original"];
    upvoteCount?: CommentUpdateType["upvoteCount"];
    downvoteCount?: CommentUpdateType["downvoteCount"];
    replyCount?: CommentUpdateType["replyCount"];
    updatedAt?: CommentUpdateType["updatedAt"];
    replies: RepliesPages;
    edit?: CommentUpdateType["edit"];
    flair?: CommentPubsubMessagePublication["flair"];
    deleted?: CommentWithinPageJson["deleted"];
    spoiler?: CommentIpfsType["spoiler"];
    nsfw?: CommentIpfsType["nsfw"];
    pinned?: CommentUpdateType["pinned"];
    locked?: CommentUpdateType["locked"];
    removed?: CommentUpdateType["removed"];
    reason?: CommentUpdateType["reason"];
    lastChildCid?: CommentUpdateType["lastChildCid"];
    lastReplyTimestamp?: CommentUpdateType["lastReplyTimestamp"];
    signature: CommentPubsubMessagePublication["signature"];
    state: CommentState;
    updatingState: CommentUpdatingState;
    raw: {
        comment?: CommentIpfsType;
        commentUpdate?: CommentUpdateType;
        pubsubMessageToPublish?: CommentPubsubMessagePublication;
        commentUpdateFromChallengeVerification?: CommentUpdateForChallengeVerification;
    };
    _commentUpdateIpfsPath?: string;
    _invalidCommentUpdateMfsPaths: Set<string>;
    private _commentIpfsloadingOperation?;
    _clientsManager: CommentClientsManager;
    private _updateRpcSubscriptionId?;
    challengeRequest?: CreateCommentOptions["challengeRequest"];
    private _subplebbitForUpdating?;
    private _postForUpdating?;
    _numOfListenersForUpdatingInstance: number;
    _updatingCommentInstance?: {
        comment: Comment;
    } & Pick<PublicationEvents, "error" | "updatingstatechange" | "update" | "statechange">;
    constructor(plebbit: Plebbit);
    _initClients(): void;
    private _setOriginalFieldBeforeModifying;
    _initLocalProps(props: {
        comment: CommentPubsubMessagePublication;
        signer?: SignerType;
        challengeRequest?: CreateCommentOptions["challengeRequest"];
    }): void;
    _initPubsubMessageProps(props: CommentPubsubMessagePublication): void;
    _initIpfsProps(props: CommentIpfsType): void;
    _initProps(props: CommentIpfsType | CommentPubsubMessagePublication): void;
    _initCommentUpdate(props: CommentUpdateType | CommentWithinPageJson, subplebbit?: Pick<SubplebbitIpfsType, "signature">): void;
    _updateRepliesPostsInstance(newReplies: CommentUpdateType["replies"] | CommentWithinPageJson["replies"] | Pick<RepliesPagesTypeIpfs, "pageCids">, subplebbit?: Pick<SubplebbitIpfsType, "signature">): void;
    private _verifyChallengeVerificationCommentProps;
    private _addOwnCommentToIpfsIfConnectedToIpfsClient;
    _initCommentUpdateFromChallengeVerificationProps(commentUpdate: CommentUpdateForChallengeVerification): void;
    private _updateCommentPropsFromDecryptedChallengeVerification;
    protected _verifyDecryptedChallengeVerificationAndUpdateCommentProps(decryptedVerification: DecryptedChallengeVerification): Promise<void>;
    getType(): PublicationTypeName;
    toJSONIpfs(): CommentIpfsType;
    toJSONPubsubMessagePublication(): CommentPubsubMessagePublication;
    setCid(newCid: string): void;
    setSubplebbitAddress(newSubplebbitAddress: string): void;
    private _isCommentIpfsErrorRetriable;
    private _retryLoadingCommentIpfs;
    _attemptToFetchCommentIpfsIfNeeded(log: Logger): Promise<void>;
    _attemptInfintelyToLoadCommentIpfs(): Promise<void>;
    startCommentUpdateSubplebbitSubscription(): Promise<void>;
    loadCommentIpfsAndStartCommentUpdateSubscription(): Promise<void>;
    _setStateNoEmission(newState: Comment["state"]): void;
    _setUpdatingStateNoEmission(newState: Comment["updatingState"]): void;
    _setUpdatingStateWithEmissionIfNewState(newState: Comment["updatingState"]): void;
    protected _setRpcClientState(newState: Comment["clients"]["plebbitRpcClients"][""]["state"]): void;
    protected _updateRpcClientStateFromUpdatingState(updatingState: Comment["updatingState"]): void;
    private _isRetriableLoadingError;
    private _handleUpdateEventFromRpc;
    private _handleUpdatingStateChangeFromRpc;
    private _handleStateChangeFromRpc;
    private _handleErrorEventFromRpc;
    private _updateViaRpc;
    _useUpdatePropsFromUpdatingCommentIfPossible(): void;
    _useUpdatingCommentFromPlebbit(updatingCommentInstance: Comment): void;
    _setUpNewUpdatingCommentInstance(): Promise<void>;
    update(): Promise<void>;
    private _stopUpdateLoop;
    stop(): Promise<void>;
    private _validateSignature;
    publish(): Promise<void>;
}

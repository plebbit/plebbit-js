import Publication from "../publication.js";
import type { DecryptedChallengeVerificationMessageType } from "../../pubsub-messages/types.js";
import type { AuthorWithOptionalCommentUpdateJson, PublicationTypeName } from "../../types.js";
import type { RepliesPagesTypeIpfs } from "../../pages/types.js";
import { Plebbit } from "../../plebbit.js";
import { CommentClientsManager } from "../../clients/client-manager.js";
import type { CommentChallengeRequestToEncryptType, CommentIpfsType, CommentIpfsWithCidPostCidDefined, CommentPubsubMessage, CommentState, CommentUpdateType, CommentUpdatingState, CommentWithinPageJson, LocalCommentOptions } from "./types.js";
import { RepliesPages } from "../../pages/pages.js";
export declare class Comment extends Publication {
    shortCid?: CommentWithinPageJson["shortCid"];
    clients: CommentClientsManager["clients"];
    author: AuthorWithOptionalCommentUpdateJson;
    title?: CommentPubsubMessage["title"];
    link?: CommentPubsubMessage["link"];
    linkWidth?: CommentPubsubMessage["linkWidth"];
    linkHeight?: CommentPubsubMessage["linkHeight"];
    thumbnailUrl?: CommentIpfsType["thumbnailUrl"];
    thumbnailUrlWidth?: CommentIpfsType["thumbnailUrlWidth"];
    thumbnailUrlHeight?: CommentIpfsType["thumbnailUrlHeight"];
    cid?: CommentIpfsWithCidPostCidDefined["cid"];
    parentCid?: CommentIpfsType["parentCid"];
    content?: CommentPubsubMessage["content"];
    previousCid?: CommentIpfsType["previousCid"];
    depth?: CommentIpfsType["depth"];
    postCid?: CommentIpfsType["postCid"];
    linkHtmlTagName?: CommentPubsubMessage["linkHtmlTagName"];
    original?: CommentWithinPageJson["original"];
    upvoteCount?: CommentUpdateType["upvoteCount"];
    downvoteCount?: CommentUpdateType["downvoteCount"];
    replyCount?: CommentUpdateType["replyCount"];
    updatedAt?: CommentUpdateType["updatedAt"];
    replies: RepliesPages;
    edit?: CommentUpdateType["edit"];
    flair?: CommentPubsubMessage["flair"];
    deleted?: CommentWithinPageJson["deleted"];
    spoiler?: CommentIpfsType["spoiler"];
    pinned?: CommentUpdateType["pinned"];
    locked?: CommentUpdateType["locked"];
    removed?: CommentUpdateType["removed"];
    reason?: CommentUpdateType["reason"];
    lastChildCid?: CommentUpdateType["lastChildCid"];
    lastReplyTimestamp?: CommentUpdateType["lastReplyTimestamp"];
    state: CommentState;
    updatingState: CommentUpdatingState;
    private _updateInterval?;
    _rawCommentUpdate?: CommentUpdateType;
    _rawCommentIpfs?: CommentIpfsType;
    private _loadingOperation?;
    _clientsManager: CommentClientsManager;
    private _updateRpcSubscriptionId?;
    _pubsubMsgToPublish?: CommentPubsubMessage;
    constructor(plebbit: Plebbit);
    _initClients(): void;
    private _setOriginalFieldBeforeModifying;
    _initLocalProps(props: LocalCommentOptions): void;
    _initPubsubMessageProps(props: CommentPubsubMessage): void;
    _initIpfsProps(props: CommentIpfsType): void;
    _initChallengeRequestProps(props: CommentChallengeRequestToEncryptType): void;
    _initProps(props: CommentIpfsType | CommentPubsubMessage): void;
    _initCommentUpdate(props: CommentUpdateType | CommentWithinPageJson): void;
    _updateRepliesPostsInstance(newReplies: CommentUpdateType["replies"] | CommentWithinPageJson["replies"] | Pick<RepliesPagesTypeIpfs, "pageCids">): void;
    protected _updateLocalCommentPropsWithVerification(props: DecryptedChallengeVerificationMessageType["publication"]): Promise<void>;
    getType(): PublicationTypeName;
    toJSONIpfs(): CommentIpfsType;
    toJSONPubsubMessagePublication(): CommentPubsubMessage;
    setCid(newCid: string): void;
    setSubplebbitAddress(newSubplebbitAddress: string): void;
    private _isCommentIpfsErrorRetriable;
    private _retryLoadingCommentIpfs;
    private _retryLoadingCommentUpdate;
    updateOnce(): Promise<void>;
    _setUpdatingState(newState: Comment["updatingState"]): void;
    protected _setRpcClientState(newState: Comment["clients"]["plebbitRpcClients"][""]["state"]): void;
    protected _updateRpcClientStateFromUpdatingState(updatingState: Comment["updatingState"]): void;
    private _isCriticalRpcError;
    private _handleUpdateEventFromRpc;
    private _handleUpdatingStateChangeFromRpc;
    private _handleStateChangeFromRpc;
    private _handleErrorEventFromRpc;
    private _updateViaRpc;
    update(): Promise<void>;
    private _stopUpdateLoop;
    stop(): Promise<void>;
    private _validateSignature;
    publish(): Promise<void>;
}

/// <reference types="node" />
import EventEmitter from "events";
import { Challenge, ChallengeAnswerMessage, ChallengeRequestMessage } from "./challenge";
import { DbHandler } from "./runtime/node/db-handler";
import { Signer, Signature } from "./signer";
import { Pages } from "./pages";
import { Plebbit } from "./plebbit";
import { ChallengeType, CreateSubplebbitOptions, Flair, FlairOwner, ProtocolVersion, SubplebbitEditOptions, SubplebbitEncryption, SubplebbitFeatures, SubplebbitMetrics, SubplebbitRole, SubplebbitSuggested, SubplebbitType } from "./types";
import { Comment } from "./comment";
import Vote from "./vote";
import Publication from "./publication";
import { CommentEdit } from "./comment-edit";
export declare const RUNNING_SUBPLEBBITS: Record<string, boolean>;
export declare class Subplebbit extends EventEmitter implements SubplebbitType {
    title?: string;
    description?: string;
    roles?: {
        [authorAddress: string]: SubplebbitRole;
    };
    latestPostCid?: string;
    posts?: Pages;
    pubsubTopic: string;
    challengeTypes?: ChallengeType[];
    metrics?: SubplebbitMetrics;
    features?: SubplebbitFeatures;
    suggested?: SubplebbitSuggested;
    flairs?: Record<FlairOwner, Flair[]>;
    address: string;
    metricsCid?: string;
    createdAt: number;
    updatedAt: number;
    signer?: Signer;
    encryption: SubplebbitEncryption;
    protocolVersion: ProtocolVersion;
    signature: Signature;
    rules?: string[];
    plebbit: Plebbit;
    dbHandler?: DbHandler;
    _keyv: any;
    _dbConfig?: any;
    private _challengeToSolution;
    private _challengeToPublication;
    private provideCaptchaCallback?;
    private validateCaptchaAnswerCallback?;
    private ipnsKeyName?;
    private sortHandler;
    private _updateInterval?;
    private _syncInterval?;
    private _sync;
    constructor(props: CreateSubplebbitOptions, plebbit: Plebbit);
    initSubplebbit(newProps: SubplebbitType | SubplebbitEditOptions): void;
    initSignerIfNeeded(): Promise<void>;
    initDbIfNeeded(): Promise<void>;
    setProvideCaptchaCallback(newCallback: (request: ChallengeRequestMessage) => Promise<[Challenge[], string | undefined]>): void;
    setValidateCaptchaAnswerCallback(newCallback: (answerMessage: ChallengeAnswerMessage) => Promise<[boolean, string[] | undefined]>): void;
    toJSONInternal(): {
        ipnsKeyName: string;
        database: any;
        signer: Signer;
        signature: import("./types").SignatureType;
        encryption: SubplebbitEncryption;
        address: string;
        createdAt: number;
        updatedAt: number;
        pubsubTopic: string;
        metricsCid?: string;
        protocolVersion: "1.0.0";
        title?: string;
        description?: string;
        roles?: {
            [authorAddress: string]: SubplebbitRole;
        };
        rules?: string[];
        latestPostCid?: string;
        posts?: Pages;
        challengeTypes?: ChallengeType[];
        metrics?: SubplebbitMetrics;
        features?: SubplebbitFeatures;
        suggested?: SubplebbitSuggested;
        flairs?: Record<FlairOwner, Flair[]>;
    };
    toJSON(): SubplebbitType;
    prePublish(): Promise<void>;
    assertDomainResolvesCorrectly(domain: string): Promise<void>;
    edit(newSubplebbitOptions: SubplebbitEditOptions): Promise<Subplebbit>;
    updateOnce(): Promise<this>;
    update(updateIntervalMs?: number): Promise<this>;
    stop(): Promise<void>;
    updateSubplebbitIpns(): Promise<void>;
    handleCommentEdit(commentEdit: CommentEdit, challengeRequestId: string): Promise<{
        reason: string;
    }>;
    handleVote(newVote: Vote, challengeRequestId: string): Promise<{
        reason: string;
    }>;
    publishPostAfterPassingChallenge(publication: any, challengeRequestId: any): Promise<any>;
    handleChallengeRequest(request: ChallengeRequestMessage): Promise<void>;
    handleChallengeAnswer(challengeAnswer: ChallengeAnswerMessage): Promise<void>;
    processCaptchaPubsub(pubsubMsg: any): Promise<void>;
    defaultProvideCaptcha(request: ChallengeRequestMessage): Promise<[Challenge[], string | undefined]>;
    defaultValidateCaptcha(answerMessage: ChallengeAnswerMessage): Promise<[boolean, string[] | undefined]>;
    syncComment(dbComment: Comment): Promise<void>;
    syncIpnsWithDb(): Promise<void>;
    _syncLoop(syncIntervalMs: number): Promise<void>;
    start(syncIntervalMs?: number): Promise<void>;
    _addPublicationToDb(publication: Publication): Promise<any>;
}

import { ChallengeAnswerMessage } from "./challenge";
import { Signer } from "./signer";
import { Pages } from "./pages";
import { Plebbit } from "./plebbit";
import { ChallengeType, DbHandlerPublicAPI, DecryptedChallengeAnswerMessageType, DecryptedChallengeRequestMessageType, Flair, FlairOwner, InternalSubplebbitType, ProtocolVersion, SubplebbitEditOptions, SubplebbitEncryption, SubplebbitFeatures, SubplebbitIpfsType, SubplebbitStats, SubplebbitRole, SubplebbitSuggested, SubplebbitType, SubplebbitEvents, SubplebbitSettings } from "./types";
import { SignatureType } from "./signer/constants";
import { TypedEmitter } from "tiny-typed-emitter";
import { SubplebbitClientsManager } from "./client";
export declare class Subplebbit extends TypedEmitter<SubplebbitEvents> implements Omit<SubplebbitType, "posts"> {
    title?: string;
    description?: string;
    roles?: {
        [authorAddress: string]: SubplebbitRole;
    };
    lastPostCid?: string;
    posts: Pages;
    pubsubTopic?: string;
    challengeTypes?: ChallengeType[];
    stats?: SubplebbitStats;
    features?: SubplebbitFeatures;
    suggested?: SubplebbitSuggested;
    flairs?: Record<FlairOwner, Flair[]>;
    address: string;
    shortAddress: string;
    statsCid?: string;
    createdAt: number;
    updatedAt: number;
    signer?: Signer;
    encryption: SubplebbitEncryption;
    protocolVersion: ProtocolVersion;
    signature: SignatureType;
    rules?: string[];
    settings?: SubplebbitSettings;
    state: "stopped" | "updating" | "started";
    startedState: "stopped" | "fetching-ipns" | "publishing-ipns" | "failed" | "succeeded";
    updatingState: "stopped" | "resolving-address" | "fetching-ipns" | "fetching-ipfs" | "failed" | "succeeded";
    plebbit: Plebbit;
    dbHandler?: DbHandlerPublicAPI;
    clients: {
        ipfsGateways: {
            [ipfsGatewayUrl: string]: {
                state: "stopped" | "fetching-ipfs" | "fetching-ipns";
            };
        };
        ipfsClients: {
            [ipfsClientUrl: string]: {
                state: "stopped" | "fetching-ipns" | "fetching-ipfs" | "publishing-ipns";
            };
        };
        pubsubClients: {
            [pubsubClientUrl: string]: {
                state: "stopped" | "waiting-challenge-requests" | "publishing-challenge" | "waiting-challenge-answers" | "publishing-challenge-verification";
            };
        };
        chainProviders: {
            [chainProviderUrl: string]: {
                state: "stopped" | "resolving-subplebbit-address" | "resolving-author-address";
            };
        };
    };
    private _challengeToSolution;
    private _challengeToPublicKey;
    private _challengeToPublication;
    private provideCaptchaCallback;
    private validateCaptchaAnswerCallback;
    private sortHandler;
    private _updateInterval?;
    private _updateIntervalMs;
    private _syncInterval?;
    private _syncIntervalMs;
    private _sync;
    private _ipfsNodeIpnsKeyNames;
    private _subplebbitUpdateTrigger;
    private _loadingOperation;
    _clientsManager: SubplebbitClientsManager;
    constructor(plebbit: Plebbit);
    initSubplebbit(newProps: InternalSubplebbitType | SubplebbitEditOptions | SubplebbitIpfsType): Promise<void>;
    private setAddress;
    private _initSignerProps;
    private initDbHandlerIfNeeded;
    setProvideCaptchaCallback(newCallback: (request: DecryptedChallengeRequestMessageType) => Promise<[ChallengeType[], string | undefined]>): void;
    setValidateCaptchaAnswerCallback(newCallback: (answerMessage: DecryptedChallengeAnswerMessageType) => Promise<[boolean, string[] | undefined]>): void;
    toJSONInternal(): InternalSubplebbitType;
    toJSON(): SubplebbitType;
    private _toJSONBase;
    toJSONIpfs(): SubplebbitIpfsType;
    private _importSignerIntoIpfsIfNeeded;
    prePublish(): Promise<void>;
    private assertDomainResolvesCorrectly;
    edit(newSubplebbitOptions: SubplebbitEditOptions): Promise<Subplebbit>;
    private _setState;
    private _setUpdatingState;
    private _setStartedState;
    private _retryLoadingSubplebbitIpns;
    private updateOnce;
    update(): Promise<void>;
    private pubsubTopicWithfallback;
    stop(): Promise<void>;
    private _validateLocalSignature;
    private updateSubplebbitIpnsIfNeeded;
    private handleCommentEdit;
    private handleVote;
    private isPublicationVote;
    private isPublicationComment;
    private isPublicationReply;
    private isPublicationPost;
    private isPublicationCommentEdit;
    private storePublicationIfValid;
    private _decryptOrRespondWithFailure;
    private handleChallengeRequest;
    handleChallengeAnswer(challengeAnswer: ChallengeAnswerMessage): Promise<void>;
    private _verifyPubsubMsgSignature;
    private handleChallengeExchange;
    private defaultProvideCaptcha;
    private defaultValidateCaptcha;
    private _publishCommentIpns;
    private _validateCommentUpdate;
    private _updateComment;
    private _listenToIncomingRequests;
    private _getDbInternalState;
    private _mergeInstanceStateWithDbState;
    private _switchDbIfNeeded;
    private _updateCommentsThatNeedToBeUpdated;
    private _repinCommentsIPFSIfNeeded;
    private syncIpnsWithDb;
    private _updateDbInternalState;
    private _syncLoop;
    start(): Promise<void>;
    delete(): Promise<void>;
}
